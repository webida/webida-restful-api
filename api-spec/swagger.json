{
  "swagger" : "2.0",
  "info" : {
    "description" : "Restful API for Webida clients to use server's data & features",
    "version" : "0.3.0",
    "title" : "Webida Restful API",
    "license" : {
      "name" : "Apache 2.0",
      "url" : "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  },
  "basePath" : "/api",
  "consumes" : [ "application/json" ],
  "produces" : [ "application/json", "application/octet-stream" ],
  "paths" : {
    "/auth/info" : {
      "get" : {
        "tags" : [ "auth" ],
        "description" : "Gets user information of that can be identified with current access token. Implementations\nshould provide a more restful api based on domain data model, not extending this operation.\n(e.g. GET,PUT and DELETE on /Users/{userId} to read, update and delete user)\n",
        "operationId" : "getInfo",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "user information",
            "schema" : {
              "$ref" : "#/definitions/User"
            }
          },
          "401" : {
            "description" : "auth failed",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/auth/getInfo.js"
      }
    },
    "/auth/login" : {
      "post" : {
        "tags" : [ "auth" ],
        "description" : "A \"VERY\" basic authentication, required to use webida-simple-auth security scheme.\n\nService / Product implementations who need better security, should override this operation\nor add their own login api or some other specs like OAuth2. Simple auth is not suitable\nfor large-sacle, multi-tennant service, for the scheme assumes a single, trusted user only.\n\nLogging-in with master token, the generated access token inherits all restriction from it.\nOn the other hand, normal log-in with login id & password creates an unrestricted access\ntoken, with reasonably short expiration time.\n\nEvery client should spawn another access token with issueToken API before current\naccess token expires, inheriting session id from current token. To save remote access\ninfo, client should create a (restricted but long-ttl) master token to start IDE from\nremote. The remote client should not use the unrestricted acccess token from login\nto use any other perpose than finding available workspaces, and should not refresh\nthe token. (Let user log-in again)\n\nLogin API does not force any encryption. Server should provide secure transport channel,\nusually https, to provide remote access, always.\n",
        "operationId" : "login",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/Credential"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "login success",
            "schema" : {
              "$ref" : "#/definitions/Token"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "x-handler" : "handlers/auth/login.js"
      }
    },
    "/auth/token" : {
      "post" : {
        "tags" : [ "auth" ],
        "description" : "Creates new token from current access token, inheriting workspace id & session id.\nThe duration of generated token is (and should not be) parameterizable. Server should\nset proper duration, respecting \"reconnect\" period of socket.io clients. Remember that\nmost of socket.io client implementations (including official js client) do not provide\nany ways to change connection parameters (header or query) while reconnecting to server.\n\nLike login API, this endpoint does not provide any encryption. Server should not set any\ndata to harm security in the token & should provide some signinig/encryption mechanism\nto protect token. Simple JSON Web Token with HMAC-SHA will do.\n",
        "operationId" : "issueToken",
        "parameters" : [ {
          "name" : "type",
          "in" : "query",
          "required" : true,
          "type" : "string",
          "enum" : [ "MASTER", "ACCESS" ]
        }, {
          "name" : "workspaceId",
          "in" : "query",
          "description" : "recommended to issue a MASTER type token to restrict remote access",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "new token generated",
            "schema" : {
              "$ref" : "#/definitions/Token"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/auth/issueToken.js"
      }
    },
    "/remotes" : {
      "get" : {
        "tags" : [ "remotes" ],
        "description" : "Get all access informations See RemoteWorkspaceAccess definition for details (no fancy\nfind / search feature yet)\n",
        "operationId" : "findRemoteAccesses",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "array of remote workspaces",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/RemoteAccess"
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/remotes/findRemoteAccesses.js"
      },
      "put" : {
        "tags" : [ "remotes" ],
        "description" : "create or update a remote workspace access information",
        "operationId" : "putRemoteAccess",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/RemoteAccess"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "remotes" ],
        "description" : "delete a remote workspace",
        "operationId" : "removeRemoteAccess",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "query",
          "description" : "workspace Id of remote workspace",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "removed remote workspace access info",
            "schema" : {
              "$ref" : "#/definitions/RemoteAccess"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ]
      }
    },
    "/sessions" : {
      "get" : {
        "tags" : [ "session" ],
        "description" : "get all / some webida sessions established to server",
        "operationId" : "findSessions",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "query",
          "description" : "find only sessions working on some given workspace",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "array of sessions",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Session"
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/session/findSessions.js"
      }
    },
    "/sessions/{sessionId}" : {
      "get" : {
        "tags" : [ "session" ],
        "description" : "get a session object by id",
        "operationId" : "getSession",
        "parameters" : [ {
          "name" : "sessionId",
          "in" : "path",
          "description" : "webida session id (usually different from socket id from sock.io)",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "session",
            "schema" : {
              "$ref" : "#/definitions/Session"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/session/getSession.js"
      },
      "delete" : {
        "tags" : [ "session" ],
        "description" : "close session with timeout",
        "operationId" : "closeSession",
        "parameters" : [ {
          "name" : "sessionId",
          "in" : "path",
          "description" : "webida session id (usually different from socket id from sock.io)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "closeAfter",
          "in" : "query",
          "description" : "waiting time before actual closing, to let client save files and prevent reconnect\n",
          "required" : true,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK.",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/session/closeSession.js"
      }
    },
    "/wfs/{wfsId}/any/{wfsPath}" : {
      "get" : {
        "tags" : [ "wfs" ],
        "description" : "Get stats of given path. (stat() returns \"stats\" object in node and POSIX system)\nSince we've no ctime/atime in Stats class, some file system changing events will\nsend 'exactly same' stats object. This API should be called only when stats of some\nfile system path is stale for unknown reason (e.g. losting change events).\nUse dirTree operation and session events to detect stats, if possible. This API\ncan be used to check a path is valid, existing one, but it's not recommended to\ncheck existence of individual paths by API. Clients should use dirTree and session\nevents to synchorize some in-app file system with webida file system.\n",
        "operationId" : "stat",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "ignoreError",
          "in" : "query",
          "description" : "flag to ignore stat errors to check existence only. If this flag is true,\nserver will returns 'DUMMY' type stats object instead of 404 error when\ngiven path does not exists. (invalid wfsId will produce 400 error, not 404)\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "stats object.",
            "schema" : {
              "$ref" : "#/definitions/Stats"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/stat.js"
      },
      "post" : {
        "tags" : [ "wfs" ],
        "description" : "Moves source resource to given path. Unlike mv command, wfsPath always denotes an exact\npath of the resource to be created. So, moving a file to existing directory always\nreturns error and vice versa. (So, This API works like 'rename' rather than 'mv' command)\n\nLike copy(), this operation creates parent path of destination, and does not roll-back\nwhen operation failes.\n\nWhen destination path exists already,\n1) moving file to file : follows noOverwrite flag.\n2) moving file to dir : returns 409 error\n3) moving dir to file : returns 409 error\n4) moving dir to dir : merge srcPath/* to wfsPath, following noOverwite flag.\n",
        "operationId" : "move",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "srcPath",
          "in" : "query",
          "description" : "source data path of some operations, with have heading /",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "noOverwrite",
          "in" : "query",
          "description" : "does not overwrites any existing file while copying or moving",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/move.js"
      },
      "put" : {
        "tags" : [ "wfs" ],
        "description" : "Creates a copy of source to given path. Unlike cp command, wfsPath always denotes an exact\npath of the resource to be created. So, copying a file to directory always returns error\nand vice versa.\n\nthis operation creates the parents dir of destination path always, and does not\nroll-back the creation when operation failed. So, clients should roll-back if needed.\n\nWhen destination path exists already,\n1) copying file to file : follows noOverwrite flag. (does not return error)\n2) copying file to dir : returns 409 error\n3) copying dir to file : returns 409 error\n4) copying dir to dir : merge srcPath/* to wfsPath, following noOverwite flag.\n",
        "operationId" : "copy",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "srcPath",
          "in" : "query",
          "description" : "source data path of some operations, with have heading /",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "noOverwrite",
          "in" : "query",
          "description" : "does not overwrites any existing file while copying or moving",
          "required" : false,
          "type" : "boolean",
          "default" : false
        }, {
          "name" : "followSymbolicLinks",
          "in" : "query",
          "description" : "dereference symlinks in source.",
          "required" : false,
          "type" : "boolean",
          "default" : false
        }, {
          "name" : "preserveTimestamps",
          "in" : "query",
          "description" : "keep mtime/atime of source file(s) in destination.",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/copy.js"
      },
      "delete" : {
        "tags" : [ "wfs" ],
        "description" : "delete file or directory",
        "operationId" : "remove",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "noRecursive",
          "in" : "query",
          "description" : "if set, deleting non-empty directory will return 409 error.",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/remove.js"
      }
    },
    "/wfs/{wfsId}/dir/{wfsPath}" : {
      "get" : {
        "tags" : [ "wfs" ],
        "description" : "returns a directory tree of given path, for listing dir and managing file system\nerrors while building sub-tree will be ignored and will not be included in result.\n",
        "operationId" : "dirTree",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "maxDepth",
          "in" : "query",
          "description" : "Maximum depth of tree. -1 to build a full tree, 0 to stat, 1 to plain list.",
          "required" : true,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "A DirEntry, root of the tree, for given path and depth.",
            "schema" : {
              "$ref" : "#/definitions/DirEntry"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/dirTree.js"
      },
      "put" : {
        "tags" : [ "wfs" ],
        "description" : "create a directory at the path. returns error when wfsPath exists and not empty\nthis API always creates parent directories if needed.\n",
        "operationId" : "createDir",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/createDir.js"
      }
    },
    "/wfs/{wfsId}/file/{wfsPath}" : {
      "get" : {
        "tags" : [ "wfs" ],
        "description" : "read file data on path",
        "operationId" : "readFile",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        } ],
        "responses" : {
          "200" : {
            "description" : "File contents. Content-Type is application/octet-stream or follows file name extension.\n",
            "schema" : {
              "type" : "file"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/readFile.js"
      },
      "put" : {
        "tags" : [ "wfs" ],
        "description" : "Creates / updates file with body data. Server should write the file in 'atomic' manner,\nand should not write down request body into final destination path directly. In other words,\nwheather writeFile() succeeds or not, the contents of the file should not be corrupted nor\nhalf-written.\n",
        "operationId" : "writeFile",
        "consumes" : [ "multipart/form-data" ],
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "ensureParents",
          "in" : "query",
          "description" : "A flag to create all parent directories to create file or dir, like mkdir -p. This parameter\ndoes not create entire path, but creates to 'parent directory' of the path.\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        }, {
          "name" : "data",
          "in" : "formData",
          "description" : "file contents to write.",
          "required" : true,
          "type" : "file"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/writeFile.js"
      }
    },
    "/wfs/{wfsId}/ops/replace" : {
      "post" : {
        "tags" : [ "ops" ],
        "description" : "replace file contents with regex matching",
        "operationId" : "replace",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPathList",
          "in" : "query",
          "description" : "array of wfsPath, with heading /  (collection format may be changed by implementation)",
          "required" : true,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "pattern",
          "in" : "query",
          "description" : "regex pattern to match in search or replace.\nIn replace operation, pattern should be same to the parttern in search operation\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "replaceTo",
          "in" : "query",
          "description" : "string to replace with",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "ignoreCase",
          "in" : "query",
          "description" : "regex matching option to ignore case.\nIn replace operation, this option should be same to one used in search operation\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "done",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/replace.js"
      }
    },
    "/wfs/{wfsId}/ops/search/{wfsPath}" : {
      "get" : {
        "tags" : [ "ops" ],
        "description" : "search files in some path, with given pattern",
        "operationId" : "search",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "pattern",
          "in" : "query",
          "description" : "regex pattern to match in search or replace.\nIn replace operation, pattern should be same to the parttern in search operation\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "ignoreCase",
          "in" : "query",
          "description" : "regex matching option to ignore case.\nIn replace operation, this option should be same to one used in search operation\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "search",
            "schema" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/definitions/Match"
                }
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/search.js"
      }
    },
    "/workspaces" : {
      "get" : {
        "tags" : [ "workspace" ],
        "description" : "Finds workspaces (no find/search parameters yet). Requires an unrestricted access token.  \n",
        "operationId" : "findWorkspaces",
        "parameters" : [ {
          "name" : "disposable",
          "in" : "query",
          "description" : "include disposable workspaces or not",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "array of local workspaces",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Workspace"
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/findWorkspaces.js"
      },
      "post" : {
        "tags" : [ "workspace" ],
        "description" : "Creates a new workspace with given local path. Requires an unrestricted access token. \n",
        "operationId" : "createWorkspace",
        "parameters" : [ {
          "name" : "localPath",
          "in" : "query",
          "description" : "a real, local path of the system (not unixified)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "workspace name property",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "description",
          "in" : "query",
          "description" : "workspace name property",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "newly created local workspace",
            "schema" : {
              "$ref" : "#/definitions/Workspace"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/createWorkspace.js"
      }
    },
    "/workspaces/{workspaceId}" : {
      "get" : {
        "tags" : [ "workspace" ],
        "description" : "get a workspace object by id",
        "operationId" : "getWorkspace",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "the workspace",
            "schema" : {
              "$ref" : "#/definitions/Workspace"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/getWorkspace.js"
      },
      "put" : {
        "tags" : [ "workspace" ],
        "description" : "Updates workspace. Some protected properties will not be changed by this api. Requires \nproper access rights in access token. \n",
        "operationId" : "updateWorkspace",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "updated Workspace object",
            "schema" : {
              "$ref" : "#/definitions/Workspace"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/updateWorkspace.js"
      },
      "delete" : {
        "tags" : [ "workspace" ],
        "description" : "This operation will remove the requested workspace when\n  1) all sessions are closed for request (will be notified by server)\n  2) excedded time limit value in closeAfter parameter\n  3) server goes down after accepting remove request\n\"willBeRemovedAt\" property can be set \"only\" by this api.\nThis API requires \"unrestricted\" access token. Even an access token has matching\nworkspace id, removing an workspace is rejected.\n",
        "operationId" : "removeWorkspace",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "closeAfter",
          "in" : "query",
          "description" : "Time in seconds to wait for all sessions save & close their data.",
          "required" : false,
          "type" : "integer",
          "default" : 0
        } ],
        "responses" : {
          "200" : {
            "description" : "removed Workspace object",
            "schema" : {
              "$ref" : "#/definitions/Workspace"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/removeWorkspace.js"
      }
    },
    "/workspaces/{workspaceId}/exec" : {
      "get" : {
        "tags" : [ "workspace" ],
        "description" : "Gets process info, created by async exec request, on this workspace. If execId is set,\nthis op finds a spawned process whose id is matching. If not, all spawned procs will be\nfound. This op does not returns error when no procs found but empty result array.\n\nThis operation requires proper access rights. (unrestricted or matching workspace id in\naccess token with parameter)\n",
        "operationId" : "findProcs",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "execId",
          "in" : "query",
          "description" : "the id of execution request(different from pid!)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "the child processes found. result does not include 'exited' procs.",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/ChildProcess"
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "x-handler" : "handlers/workspace/findProcs.js"
      },
      "post" : {
        "tags" : [ "workspace" ],
        "description" : "execute a shell command on this workspace. requires proper access rights.",
        "operationId" : "exec",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "async",
          "in" : "query",
          "description" : "Spawn a child process for given command and returns the created child proc info.\nActual output (stream of message) will be delivered to web socket channel, with\nroom id /sessions/async-{execId}\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        }, {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/Execution"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Execution result with all captured standard ouput and error. If execution is completed\nwithout error, cancelesponse#error should be a falsy value. If some error has happened,\nthen ExecutionResult#error (and #stderr, optionally) should be set. For other cases\n(e.g. insufficient/invalid arguments), normal RestError should be returned with 4xx\nor 5xx error code. client-side callback should distinguish from execution error from\nplain RestError.\n",
            "schema" : {
              "$ref" : "#/definitions/ExecutionResult"
            }
          },
          "201" : {
            "description" : "spawned process infomation created by async execution. If server could not create\na child process, error event will be sent to client via socket channel but RestError\nwill not be ruturned from this operation. When a client has got 'error' event from\nthe socket channel, the client should close the channel wheather it receives subsequent\nexit event or not (with some proper timeout if needed). Server should not send the\nerrors related to 'killing' child processes\n",
            "schema" : {
              "$ref" : "#/definitions/ChildProcess"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/exec.js"
      },
      "delete" : {
        "tags" : [ "workspace" ],
        "description" : "cancels an execution, if possible. Killing process may not be graceful. requires proper\naccess rights. if execId is not specified, this api does nothing.\n",
        "operationId" : "cancel",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "execId",
          "in" : "query",
          "description" : "the id of execution request(different from pid!)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ]
      }
    }
  },
  "securityDefinitions" : {
    "webida-simple-auth" : {
      "type" : "apiKey",
      "name" : "Authorization",
      "in" : "header",
      "x-authorize" : "webida-simple-auth.js"
    }
  },
  "definitions" : {
    "RestOK" : {
      "type" : "object",
      "properties" : {
        "message" : {
          "type" : "string"
        }
      }
    },
    "RestError" : {
      "type" : "object",
      "required" : [ "message" ],
      "properties" : {
        "code" : {
          "type" : "string"
        },
        "message" : {
          "type" : "string"
        }
      },
      "description" : "Error object with code and message. code is bound to status code, but not always same to\nstandard HTTP status text. For example, some 409 error may have code \"Invalid Argument\"\ninstead of \"Conflic\". So, Client should read message property to know what happend exactly\nwhen an error is returned from server. And, some 500 errors can have system errno instead\nof useless \"internal\". Like other errors, details are hidden in message.\n"
    },
    "Token" : {
      "type" : "object",
      "required" : [ "expiresAt", "issuedAt", "text", "tokenType" ],
      "properties" : {
        "text" : {
          "type" : "string",
          "description" : "actual token text that should be shipped in header or query"
        },
        "tokenType" : {
          "type" : "string",
          "description" : "MASTER : used to create an access token from clients, without login credential\nACCESS : protects api access. should be unique for each ide session\n\nNote that here\"s no REFRESH token, nor LOGIN token. The login api will create\nunrestricted access token & master token pair. Desktop app has a side-way to\ncreate an unrestricted master token before starting IDE instances.\n",
          "enum" : [ "MASTER", "ACCESS" ]
        },
        "expiresAt" : {
          "type" : "string",
          "format" : "date-time"
        },
        "issuedAt" : {
          "type" : "string",
          "format" : "date-time"
        },
        "sessionId" : {
          "type" : "string",
          "description" : "mandatory for ACCESS token, identifying client instance"
        },
        "workspaceId" : {
          "type" : "string",
          "description" : "If truthy, access rights are restricted to specified workspace only."
        }
      },
      "description" : "a json webtoken and accessible data"
    },
    "Credential" : {
      "type" : "object",
      "required" : [ "loginId", "loginPassword" ],
      "properties" : {
        "loginId" : {
          "type" : "string"
        },
        "loginPassword" : {
          "type" : "string"
        },
        "masterToken" : {
          "type" : "string",
          "description" : "a master token is issued when user wants to access webida api without id/password\nfrom remote or local desktop app. When masterToken is set, client should put some\nbogus id/password, non-empty. (The values can be used to identify client type)\n"
        }
      },
      "description" : "user credential to login. Use https to protect credential."
    },
    "User" : {
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "unique id per user (email is also unique)"
        },
        "email" : {
          "type" : "string"
        },
        "name" : {
          "type" : "string"
        }
      },
      "description" : "Any services/products should define some admin apis to manage users in the system and\nexpose what should be exposed to client app. So, no properties are mandatory.\nCurrently, the properties are defined for compatiblity with legacy clients.\n"
    },
    "Stats" : {
      "type" : "object",
      "required" : [ "birthtime", "mode", "mtime", "nlink", "size", "type" ],
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "All types except 'DUMMY' come from fs.Stats is*** methods results. (e.g. if isFile()\nis true, then type will be 'FILE') If type is not decidable by the methods, default type\nis 'FILE', for everything on the file system is basically a file. 'DUMMY' type means\nthat some object 'does not exist for now'. Client may use 'DUMMY' type to mark something\ndangling, not written or created on real file system yet but visible to user.\n",
          "enum" : [ "FILE", "DIRECTORY", "BLOCK_DEVICE", "CHARACTER_DEVICE", "LINK", "FIFO", "SOCKET", "DUMMY" ]
        },
        "birthtime" : {
          "type" : "string",
          "format" : "date-time"
        },
        "mtime" : {
          "type" : "string",
          "format" : "date-time"
        },
        "mode" : {
          "type" : "string"
        },
        "size" : {
          "type" : "integer"
        },
        "nlink" : {
          "type" : "integer"
        }
      },
      "description" : "simplified/augmented fs.Stats class - see node.js doc for all properties"
    },
    "DirEntry" : {
      "type" : "object",
      "required" : [ "children", "name", "stats" ],
      "properties" : {
        "name" : {
          "type" : "string"
        },
        "stats" : {
          "$ref" : "#/definitions/Stats"
        },
        "children" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/DirEntry"
          }
        }
      },
      "description" : "a directory entry (file or directory) with children that represents a (sub) tree"
    },
    "Match" : {
      "type" : "object",
      "required" : [ "line", "text" ],
      "properties" : {
        "line" : {
          "type" : "integer"
        },
        "text" : {
          "type" : "string"
        }
      },
      "description" : "search result for a file"
    },
    "Workspace" : {
      "type" : "object",
      "required" : [ "createdAt", "description", "excludedPaths", "id", "name", "offlineCachePaths", "workspacePath" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "the id of a workspace. usually same to file system id"
        },
        "name" : {
          "type" : "string",
          "description" : "display text of this workspace for UI"
        },
        "description" : {
          "type" : "string",
          "description" : "human readable description on this workspace"
        },
        "createdAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when this workspace is created (registered from local file system)"
        },
        "accessedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when the last session on this workspace was made. (optional)"
        },
        "workspacePath" : {
          "type" : "string",
          "description" : "absolute path of this workspace in server."
        },
        "excludedPaths" : {
          "type" : "array",
          "description" : "glob patterns (Not regular expression!) or directory paths (Not a file path!) to\nbe excluded for watch service and search & replace operation. If a value has no '*'\nchar, it will be treated as directory path.\n\nLike most of operation parameters, paths (and patterns not prefixed with '*') should\nhave relative, unixified form. If not, server should reject or discard the absolute\n values.\n\nIf a directory is specified to be excluded, watch service may deliver unlinkDir/addDir\nevents of the dir, but should not deliver any events from its sub-dirs and files.\nSearch and replace operation should ignore any files under the directory. If path\ndenotes a file, server may reject or discard the path.\n\nServer should support basic glob pattern,  '**' and '*' in the glob pattern but not !\n'!' prefix is optional. Client should not register any other extended glob features\nthat server does not support.\n",
          "items" : {
            "type" : "string"
          }
        },
        "offlineCachePaths" : {
          "type" : "array",
          "description" : "any paths (including excluded paths) to be cached in remote clients.\n\nBrowser client should respect offline cache paths always. Desktop-app client\nmay not use off-line cache for local (embedded) server but shall use cache for any\nremote servers, even for same host. All caches should be partitioned with workspace\nid, globally unique value through time and space.\n\nClient should pre-fetch the contents of offline cache paths when it start IDE sessions\non a workspace to use for off-line state. When client goes to off-line, after losing\nconnection to server, it can use cached data as reply of some WFS operations and can\nwrite some data to cache to save workspace data & metadata. The changes should be\npersistent on client side safely. C\n\nWhen a client recovers connectivity to server, it should check the stats of files and\ndirs to upload if it has got some changes in offline state. If server has more recents\ncontents, client should drop chagnes and refill the cache with fresher data. Client may\nhave some 'time-tolerance' to accept server's data is fresher than client's, smaller than\nserveral seconds. If server has more recent contents, client should drop the changes and\nrefill the cache with fresher data. If not, client should replay the changes 1 by 1.\n\nSame protocol should be applied when client application starts with some 'unuploaded\nchange' evertime. That means, client should save 'change history' with 'changed data'\ntoo, to process it later, when starting app again in normal condition.\n\nAll Clients should not replay any 'delete' operations while replaying changes on client's\ncache, to protect from more serious problems with skewed timer or unexpected behaviors.\nAnd, of course, client should not rely on cached data while connection state is healthy.\n",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "A workspace in server"
    },
    "RemoteAccess" : {
      "type" : "object",
      "required" : [ "masterToken", "name", "serverUrl", "workspaceId" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "display text of remote workspace. can be different from original name.\n"
        },
        "serverUrl" : {
          "type" : "string",
          "description" : "the url of remote server. Should have no path/query parameters, even \"/\" in path.\n"
        },
        "workspaceId" : {
          "type" : "string",
          "description" : "the id of remote workspace, read from remote server"
        },
        "workspacePath" : {
          "type" : "string",
          "description" : "Full path of remote workspace, read from remote server. this property will be removed\nwhen clients are able to work without \"named root directory\" in workspace fs tree.\n"
        },
        "masterToken" : {
          "type" : "string",
          "description" : "master token to access service, issued from remote server"
        }
      },
      "description" : "Access information of remote workspace in remote server"
    },
    "Session" : {
      "type" : "object",
      "required" : [ "clientAddress", "connectedAt", "disconnectedAt", "id", "name", "state" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "the id of a session. usually same to socket id."
        },
        "name" : {
          "type" : "string",
          "description" : "human readable name, usually derived from workspace name."
        },
        "state" : {
          "type" : "string",
          "description" : "state of this session\nNORMAL = connected, normally working\nLOSING = disconnected, waiting reconnection. still accessible with api\nCLOSING = socket connection will close connection by server (clinet will be notified)\nthere\"s no \"CLOSED\" / \"LOST\" state, for server will remove session object in registry\nwhen the server closes connection or stops waiting for reconnection for timeout.\n",
          "enum" : [ "NORMAL", "LOSING", "CLOSING" ]
        },
        "workspaceId" : {
          "type" : "string",
          "description" : "the id of workspace that this sessions is working on. If falsy, then this session is\nnot belonged to any workpsace. Usually, dashboard / monitoring app will create a session\nwithout workspace id.\n"
        },
        "clientAddress" : {
          "type" : "string",
          "description" : "the peer address of session connection. not always"
        },
        "connectedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when socket connection is established"
        },
        "disconnectedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when socket is closed."
        },
        "willCloseAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "when state becomes CLOSING, actual closing time will be updated by server."
        },
        "willLoseAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "when state becomes LOSING, server will not wait for reconnection after this time."
        }
      },
      "description" : "an application session per ide instance. bound to access token"
    },
    "Execution" : {
      "type" : "object",
      "required" : [ "args", "command" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "unique identifier of execution, to demux response stream or cancel request.\nServer should reject an async exec request without id.\n"
        },
        "command" : {
          "type" : "string",
          "description" : "The command to run. Server may not support pipe, redirection nor shell variables in\ncommand. Client should not assume any 'specific shell' in server and should not\nusing the shell features for portability.\n\nIn windows system with unix sh (e.g. cygwin or mingw from git-for-windows), usually\na shell script in PATH may work as command but probably allocates console window while\nrunning the command. Implementations (both of server & client) should avoid allocating\nadditional console device while running service for costs and UX,  and should provide\na portable way to invoke commands. Shortly, when a service/product embeds some\n'.sh' file to run, it must provide '.cmd' file doing same thing, always.\n"
        },
        "args" : {
          "type" : "array",
          "description" : "the arguments array. Server can join this args to command with proper white-space char,\nwhen underlying platform api (e.g. child_process#exec() in node.js) does not support\nadditional arguments vector. It's recommended to use args vector than making a long\ncommand, to find & see child processes easily with this Rest API. So, args should be\nalways provided, even empty array.\n\nWhen some arguments has a white space (e.g. C:\\Program Files\\webida), usually invoking\ncommand understands escaping or quotation, but not always. Client should add proper\nescaping or quotation chars to args vector manually. server should not change any\ncommand or arguments.\n",
          "items" : {
            "type" : "string"
          }
        },
        "cwd" : {
          "type" : "string",
          "description" : "Current working directory of spawned process, relative to workspace root. If abscent,\ncwd will be the workspace directory. Does not accept any evaluatable form like\n$HOME, %USERPROFILE%. path should be unixified. Server may reject an 'absolute'\nproperty.\n"
        },
        "timeout" : {
          "type" : "integer",
          "description" : "The value which In 'miliseconds' the maximum amount of time the child is allowed\nto run. (not idle time of stdout / stderr stream) for sync exec. Server should not\napply default value for async exec, when omitted. The child process spawned by async\nexecution should be killed when\n 1) server goes down\n 2) process exits by self\n 3) cancel operation is invoked\n"
        },
        "maxBuffer" : {
          "type" : "integer",
          "description" : "Largest amount of data (in bytes) allowed on stdout or stderr for sync exec. Server\nshould not apply this limit to async execution. In sync exec, server may kill a\nchild process that has exceeded limit. default value is 512KB, large enough.\n"
        }
      },
      "description" : "execution request, simlilar to node.js exec()/spawn(). see node.js documentation for\ndetails of each properties. some properties are not configurable for portability\n   - encoding : fixed to utf-8\n   - shell : fixed to system defaults. (so, cmd.exe will be invoked in Windows OS, not sh\n            or bash in git-for-windows even they are available.)\n   - killSignal : fixed to SIGTERM. If process does not die, server can send SIGKILL or\n                  invoke taskkill, to ensure chlid process is killed.\n   - uid & gid : will not be set for security\n   - stdio : all streams are handled by server. no options are avaliable to client.\n   - detached : always false\n"
    },
    "ExecutionResult" : {
      "type" : "object",
      "required" : [ "stderr", "stdout" ],
      "properties" : {
        "error" : {
          "type" : "string",
          "description" : "error message when execution failed."
        },
        "stdout" : {
          "type" : "string",
          "description" : "standard out of child process."
        },
        "stderr" : {
          "type" : "string",
          "description" : "standard error of child process."
        }
      },
      "description" : "execution response"
    },
    "ChildProcess" : {
      "type" : "object",
      "required" : [ "args", "command", "execId", "pid", "startedAt", "state" ],
      "properties" : {
        "pid" : {
          "type" : "integer",
          "description" : "child process pid"
        },
        "command" : {
          "type" : "string",
          "description" : "execution command in execution request"
        },
        "args" : {
          "type" : "array",
          "description" : "arguments of command in execution request",
          "items" : {
            "type" : "string"
          }
        },
        "execId" : {
          "type" : "string",
          "description" : "execution id from execution request"
        },
        "state" : {
          "type" : "string",
          "description" : "state of process. Where\n  CREATED - process is just created. no event has arrived yet\n  WORKING - some output on stdout/stderr is arrived\n  KILLING - sent kill signal, by cancel operation or error event from the process\n  EXITED  - process has exited.\n",
          "enum" : [ "CREATED", "WORKING", "KILLING", "EXITED" ]
        },
        "startedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when this process is spawned"
        },
        "exitCode" : {
          "type" : "integer",
          "description" : "the exit code of child process. available with EXITED procs only."
        },
        "exitSignal" : {
          "type" : "string",
          "description" : "the signal that killed this child process.(not always available)"
        }
      },
      "description" : "a process in execution, spawned by async exec or other mean"
    }
  },
  "parameters" : {
    "wfsId" : {
      "name" : "wfsId",
      "in" : "path",
      "description" : "webida file system id (same to workspace id) to access.",
      "required" : true,
      "type" : "string"
    },
    "wfsPath" : {
      "name" : "wfsPath",
      "in" : "path",
      "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
      "required" : true,
      "type" : "string",
      "pattern" : ".*"
    },
    "srcPath" : {
      "name" : "srcPath",
      "in" : "query",
      "description" : "source data path of some operations, with have heading /",
      "required" : true,
      "type" : "string"
    },
    "wfsPathList" : {
      "name" : "wfsPathList",
      "in" : "query",
      "description" : "array of wfsPath, with heading /  (collection format may be changed by implementation)",
      "required" : true,
      "type" : "array",
      "items" : {
        "type" : "string"
      },
      "collectionFormat" : "multi"
    },
    "ensureParents" : {
      "name" : "ensureParents",
      "in" : "query",
      "description" : "A flag to create all parent directories to create file or dir, like mkdir -p. This parameter\ndoes not create entire path, but creates to 'parent directory' of the path.\n",
      "required" : false,
      "type" : "boolean",
      "default" : false
    },
    "noOverwrite" : {
      "name" : "noOverwrite",
      "in" : "query",
      "description" : "does not overwrites any existing file while copying or moving",
      "required" : false,
      "type" : "boolean",
      "default" : false
    },
    "pattern" : {
      "name" : "pattern",
      "in" : "query",
      "description" : "regex pattern to match in search or replace.\nIn replace operation, pattern should be same to the parttern in search operation\n",
      "required" : true,
      "type" : "string"
    },
    "ignoreCase" : {
      "name" : "ignoreCase",
      "in" : "query",
      "description" : "regex matching option to ignore case.\nIn replace operation, this option should be same to one used in search operation\n",
      "required" : false,
      "type" : "boolean",
      "default" : false
    },
    "workspaceId" : {
      "name" : "workspaceId",
      "in" : "path",
      "description" : "webida workspace id (usually same to file system id, wfsId)",
      "required" : true,
      "type" : "string"
    },
    "execId" : {
      "name" : "execId",
      "in" : "query",
      "description" : "the id of execution request(different from pid!)",
      "required" : false,
      "type" : "string"
    },
    "sessionId" : {
      "name" : "sessionId",
      "in" : "path",
      "description" : "webida session id (usually different from socket id from sock.io)",
      "required" : true,
      "type" : "string"
    }
  }
}