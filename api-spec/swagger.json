{
  "swagger" : "2.0",
  "info" : {
    "description" : "Restful API for Webida clients to use server's data & features",
    "version" : "0.3.0",
    "title" : "Webida Restful API",
    "license" : {
      "name" : "Apache 2.0",
      "url" : "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  },
  "basePath" : "/api",
  "consumes" : [ "application/json" ],
  "produces" : [ "application/json", "application/octet-stream" ],
  "paths" : {
    "/auth/info" : {
      "get" : {
        "tags" : [ "auth" ],
        "description" : "Gets user information of that can be identified with current access token. Implementations\nshould provide a more restful api based on domain data model, not extending this operation.\n(e.g. GET,PUT and DELETE on /Users/{userId} to read, update and delete user)\n",
        "operationId" : "getInfo",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "user information",
            "schema" : {
              "$ref" : "#/definitions/User"
            }
          },
          "401" : {
            "description" : "auth failed",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/auth/getInfo.js"
      }
    },
    "/auth/login" : {
      "post" : {
        "tags" : [ "auth" ],
        "description" : "A \"VERY\" basic authentication, required to use webida-simple-auth security scheme.\n\nService / Product implementations who need better security, should override this operation\nor add their own login api or some other specs like OAuth2. Simple auth is not suitable\nfor large-sacle, multi-tennant service, for the scheme assumes a single, trusted user only.\n\nLogging-in with master token, the generated access token inherits all restriction from it.\nOn the other hand, normal log-in with login id & password creates an unrestricted access\ntoken, with reasonably short expiration time.\n\nEvery client should spawn another access token with issueToken API before current\naccess token expires, inheriting session id from current token. To save remote access\ninfo, client should create a (restricted but long-ttl) master token to start IDE from\nremote. The remote client should not use the unrestricted acccess token from login\nto use any other perpose than finding available workspaces, and should not refresh\nthe token. (Let user log-in again)\n\nLogin API does not force any encryption. Server should provide secure transport channel,\nusually https, to provide remote access, always.\n",
        "operationId" : "login",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/Credential"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "login success",
            "schema" : {
              "$ref" : "#/definitions/Token"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "x-handler" : "handlers/auth/login.js"
      }
    },
    "/auth/token" : {
      "post" : {
        "tags" : [ "auth" ],
        "description" : "Creates new token from current access token, inheriting workspace id & session id.\nThe duration of generated token is (and should not be) parameterizable. Server should\nset proper duration, respecting \"reconnect\" period of socket.io clients. Remember that\nmost of socket.io client implementations (including official js client) do not provide\nany ways to change connection parameters (header or query) while reconnecting to server.\n\nLike login API, this endpoint does not provide any encryption. Server should not set any\ndata to harm security in the token & should provide some signinig/encryption mechanism\nto protect token. Simple JSON Web Token with HMAC-SHA will do.\n",
        "operationId" : "issueToken",
        "parameters" : [ {
          "name" : "type",
          "in" : "query",
          "required" : true,
          "type" : "string",
          "enum" : [ "MASTER", "ACCESS" ]
        }, {
          "name" : "workspaceId",
          "in" : "query",
          "description" : "recommended to issue a MASTER type token to restrict remote access",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "new token generated",
            "schema" : {
              "$ref" : "#/definitions/Token"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/auth/issueToken.js"
      }
    },
    "/remotes" : {
      "get" : {
        "tags" : [ "remotes" ],
        "description" : "Get all access informations See RemoteWorkspaceAccess definition for details (no fancy\nfind / search feature yet)\n",
        "operationId" : "findRemoteAccesses",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "array of remote workspaces",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/RemoteAccess"
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/remotes/findRemoteAccesses.js"
      },
      "put" : {
        "tags" : [ "remotes" ],
        "description" : "create or update a remote workspace access information",
        "operationId" : "putRemoteAccess",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/RemoteAccess"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "remotes" ],
        "description" : "delete a remote workspace",
        "operationId" : "removeRemoteAccess",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "query",
          "description" : "workspace Id of remote workspace",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "removed remote workspace access info",
            "schema" : {
              "$ref" : "#/definitions/RemoteAccess"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ]
      }
    },
    "/sessions" : {
      "get" : {
        "tags" : [ "session" ],
        "description" : "get all / some webida sessions established to server",
        "operationId" : "findSessions",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "query",
          "description" : "find only sessions working on some given workspace",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "array of sessions",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Session"
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/session/findSessions.js"
      }
    },
    "/sessions/{sessionId}" : {
      "get" : {
        "tags" : [ "session" ],
        "description" : "get a session object by id",
        "operationId" : "getSession",
        "parameters" : [ {
          "name" : "sessionId",
          "in" : "path",
          "description" : "webida session id (usually different from socket id from sock.io)",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "session",
            "schema" : {
              "$ref" : "#/definitions/Session"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/session/getSession.js"
      },
      "delete" : {
        "tags" : [ "session" ],
        "description" : "close session with timeout",
        "operationId" : "closeSession",
        "parameters" : [ {
          "name" : "sessionId",
          "in" : "path",
          "description" : "webida session id (usually different from socket id from sock.io)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "closeAfter",
          "in" : "query",
          "description" : "waiting time before actual closing, to let client save files and prevent reconnect\n",
          "required" : true,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK.",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/session/closeSession.js"
      }
    },
    "/wfs/{wfsId}/any/{wfsPath}" : {
      "get" : {
        "tags" : [ "wfs" ],
        "description" : "Get stats of given path. (stat() returns \"stats\" object in node and POSIX system)\nSince we've no ctime/atime in Stats class, some file system changing events will\nsend 'exactly same' stats object. This API should be called only when stats of some\nfile system path is stale for unknown reason (e.g. losting change events).\nUse dirTree operation and session events to detect stats, if possible. This API\ncan be used to check a path is valid, existing one, but it's not recommended to\ncheck existence of individual paths by API. Clients should use dirTree and session\nevents to synchorize some in-app file system with webida file system.\n",
        "operationId" : "stat",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "ignoreError",
          "in" : "query",
          "description" : "flag to ignore stat errors to check existence only. If this flag is true,\nserver will returns 'DUMMY' type stats object instead of 404 error when\ngiven path does not exists. (invalid wfsId will produce 400 error, not 404)\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "stats object.",
            "schema" : {
              "$ref" : "#/definitions/Stats"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/stat.js"
      },
      "post" : {
        "tags" : [ "wfs" ],
        "description" : "Moves source resource to given path. Unlike mv command, wfsPath always denotes an exact\npath of the resource to be created. So, moving a file to existing directory always\nreturns error and vice versa. (So, This API works like 'rename' rather than 'mv' command)\n\nLike copy(), this operation creates parent path of destination, and does not roll-back\nwhen operation failes.\n\nWhen destination path exists already,\n1) moving file to file : follows noOverwrite flag.\n2) moving file to dir : returns 409 error\n3) moving dir to file : returns 409 error\n4) moving dir to dir : merge srcPath/* to wfsPath, following noOverwite flag.\n",
        "operationId" : "move",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "srcPath",
          "in" : "query",
          "description" : "source data path of some operations, with have heading /",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "noOverwrite",
          "in" : "query",
          "description" : "does not overwrites any existing file while copying or moving",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/move.js"
      },
      "put" : {
        "tags" : [ "wfs" ],
        "description" : "Creates a copy of source to given path. Unlike cp command, wfsPath always denotes an exact\npath of the resource to be created. So, copying a file to directory always returns error\nand vice versa.\n\nthis operation creates the parents dir of destination path always, and does not\nroll-back the creation when operation failed. So, clients should roll-back if needed.\n\nWhen destination path exists already,\n1) copying file to file : follows noOverwrite flag. (does not return error)\n2) copying file to dir : returns 409 error\n3) copying dir to file : returns 409 error\n4) copying dir to dir : merge srcPath/* to wfsPath, following noOverwite flag.\n",
        "operationId" : "copy",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "srcPath",
          "in" : "query",
          "description" : "source data path of some operations, with have heading /",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "noOverwrite",
          "in" : "query",
          "description" : "does not overwrites any existing file while copying or moving",
          "required" : false,
          "type" : "boolean",
          "default" : false
        }, {
          "name" : "followSymbolicLinks",
          "in" : "query",
          "description" : "dereference symlinks in source.",
          "required" : false,
          "type" : "boolean",
          "default" : false
        }, {
          "name" : "preserveTimestamps",
          "in" : "query",
          "description" : "keep mtime/atime of source file(s) in destination.",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/copy.js"
      },
      "delete" : {
        "tags" : [ "wfs" ],
        "description" : "delete file or directory",
        "operationId" : "remove",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "noRecursive",
          "in" : "query",
          "description" : "if set, deleting non-empty directory will return 409 error.",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/remove.js"
      }
    },
    "/wfs/{wfsId}/dir/{wfsPath}" : {
      "get" : {
        "tags" : [ "wfs" ],
        "description" : "returns a directory tree of given path, for listing dir and managing file system\nerrors while building sub-tree will be ignored and will not be included in result.\n",
        "operationId" : "dirTree",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "maxDepth",
          "in" : "query",
          "description" : "Maximum depth of tree. -1 to build a full tree, 0 to stat, 1 to plain list.",
          "required" : true,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "A DirEntry, root of the tree, for given path and depth.",
            "schema" : {
              "$ref" : "#/definitions/DirEntry"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/dirTree.js"
      },
      "put" : {
        "tags" : [ "wfs" ],
        "description" : "create a directory at the path. returns error when wfsPath exists and not empty\nthis API always creates parent directories if needed.\n",
        "operationId" : "createDir",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/createDir.js"
      }
    },
    "/wfs/{wfsId}/file/{wfsPath}" : {
      "get" : {
        "tags" : [ "wfs" ],
        "description" : "read file data on path",
        "operationId" : "readFile",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        } ],
        "responses" : {
          "200" : {
            "description" : "File contents. Content-Type is application/octet-stream or follows file name extension.\n",
            "schema" : {
              "type" : "file"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/readFile.js"
      },
      "put" : {
        "tags" : [ "wfs" ],
        "description" : "Creates / updates file with body data. Server should write the file in 'atomic' manner,\nand should not write down request body into final destination path directly. In other words,\nwheather writeFile() succeeds or not, the contents of the file should not be corrupted nor\nhalf-written.\n",
        "operationId" : "writeFile",
        "consumes" : [ "multipart/form-data" ],
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "ensureParents",
          "in" : "query",
          "description" : "A flag to create all parent directories to create file or dir, like mkdir -p. This parameter\ndoes not create entire path, but creates to 'parent directory' of the path.\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        }, {
          "name" : "data",
          "in" : "formData",
          "description" : "file contents to write.",
          "required" : true,
          "type" : "file"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/writeFile.js"
      }
    },
    "/wfs/{wfsId}/ops/replace" : {
      "post" : {
        "tags" : [ "ops" ],
        "description" : "replace file contents with regex matching",
        "operationId" : "replace",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPathList",
          "in" : "query",
          "description" : "array of wfsPath, with heading /  (collection format may be changed by implementation)",
          "required" : true,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "pattern",
          "in" : "query",
          "description" : "regex pattern to match in search or replace.\nIn replace operation, pattern should be same to the parttern in search operation\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "replaceTo",
          "in" : "query",
          "description" : "string to replace with",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "ignoreCase",
          "in" : "query",
          "description" : "regex matching option to ignore case.\nIn replace operation, this option should be same to one used in search operation\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "done",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/replace.js"
      }
    },
    "/wfs/{wfsId}/ops/search/{wfsPath}" : {
      "get" : {
        "tags" : [ "ops" ],
        "description" : "search files in some path, with given pattern",
        "operationId" : "search",
        "parameters" : [ {
          "name" : "wfsId",
          "in" : "path",
          "description" : "webida file system id (same to workspace id) to access.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "wfsPath",
          "in" : "path",
          "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
          "required" : true,
          "type" : "string",
          "pattern" : ".*"
        }, {
          "name" : "pattern",
          "in" : "query",
          "description" : "regex pattern to match in search or replace.\nIn replace operation, pattern should be same to the parttern in search operation\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "ignoreCase",
          "in" : "query",
          "description" : "regex matching option to ignore case.\nIn replace operation, this option should be same to one used in search operation\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "search",
            "schema" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/definitions/Match"
                }
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/wfs/search.js"
      }
    },
    "/workspaces" : {
      "get" : {
        "tags" : [ "workspace" ],
        "description" : "Finds workspaces (no find/search parameters yet). Requires an unrestricted access token.  \n",
        "operationId" : "findWorkspaces",
        "parameters" : [ {
          "name" : "disposable",
          "in" : "query",
          "description" : "include disposable workspaces or not",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "array of local workspaces",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Workspace"
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/findWorkspaces.js"
      },
      "post" : {
        "tags" : [ "workspace" ],
        "description" : "Creates a new workspace with given local path. Requires an unrestricted access token. \n",
        "operationId" : "createWorkspace",
        "parameters" : [ {
          "name" : "localPath",
          "in" : "query",
          "description" : "a real, local path of the system (not unixified)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "workspace name property",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "description",
          "in" : "query",
          "description" : "workspace name property",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "newly created local workspace",
            "schema" : {
              "$ref" : "#/definitions/Workspace"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/createWorkspace.js"
      }
    },
    "/workspaces/{workspaceId}" : {
      "get" : {
        "tags" : [ "workspace" ],
        "description" : "get a workspace object by id",
        "operationId" : "getWorkspace",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "the workspace",
            "schema" : {
              "$ref" : "#/definitions/Workspace"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/getWorkspace.js"
      },
      "put" : {
        "tags" : [ "workspace" ],
        "description" : "Updates workspace. Some protected properties will not be changed by this api. Requires \nproper access rights in access token. \n",
        "operationId" : "updateWorkspace",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "updated Workspace object",
            "schema" : {
              "$ref" : "#/definitions/Workspace"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/updateWorkspace.js"
      },
      "delete" : {
        "tags" : [ "workspace" ],
        "description" : "This operation will remove the requested workspace when\n  1) all sessions are closed for request (will be notified by server)\n  2) excedded time limit value in closeAfter parameter\n  3) server goes down after accepting remove request\n\"willBeRemovedAt\" property can be set \"only\" by this api.\nThis API requires \"unrestricted\" access token. Even an access token has matching\nworkspace id, removing an workspace is rejected.\n",
        "operationId" : "removeWorkspace",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "closeAfter",
          "in" : "query",
          "description" : "Time in seconds to wait for all sessions save & close their data.",
          "required" : false,
          "type" : "integer",
          "default" : 0
        } ],
        "responses" : {
          "200" : {
            "description" : "removed Workspace object",
            "schema" : {
              "$ref" : "#/definitions/Workspace"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/removeWorkspace.js"
      }
    },
    "/workspaces/{workspaceId}/exec" : {
      "get" : {
        "tags" : [ "workspace" ],
        "description" : "get all spawned process info, created by exec api, on given workspace. set workspace id to\n\"*\" to all processes info. This operation requires proper access rights (unrestricted or\nmatching workspace id in access token with parameter)\n",
        "operationId" : "getChildProcs",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "includeExec",
          "in" : "query",
          "description" : "include processes created by synchronous exec request",
          "required" : false,
          "type" : "boolean",
          "default" : false
        } ],
        "responses" : {
          "200" : {
            "description" : "execution result with all captured standard ouput and error",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/ChildProcess"
              }
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "x-handler" : "handlers/workspace/getChildProcs.js"
      },
      "post" : {
        "tags" : [ "workspace" ],
        "description" : "execute a shell command on this workspace",
        "operationId" : "exec",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "async",
          "in" : "query",
          "description" : "Spawn a child process for given command and returns a child process info only. ,\nActual output (stream of message) will be delivered to web socket channel, with\nroom id /sessions/asyn-{Execution#id}\n",
          "required" : false,
          "type" : "boolean",
          "default" : false
        }, {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/Execution"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "execution result with all captured standard ouput and error",
            "schema" : {
              "$ref" : "#/definitions/ExecutionResult"
            }
          },
          "201" : {
            "description" : "spawned process infomation created by async execution",
            "schema" : {
              "$ref" : "#/definitions/ChildProcess"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/exec.js"
      },
      "delete" : {
        "tags" : [ "workspace" ],
        "description" : "cancels an execution, if possible. Killing process may not be graceful.",
        "operationId" : "cancel",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "execId",
          "in" : "query",
          "description" : "the id of execution (different from pid!)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ]
      }
    },
    "/workspaces/{workspaceId}/metadata/{objectPath}" : {
      "get" : {
        "tags" : [ "workspace" ],
        "description" : "read a metadata file from a workspace.",
        "operationId" : "readMetadata",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "objectPath",
          "in" : "path",
          "description" : "the path (filename without .json) of metadata, without heading /",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "the metadata file contents at given path",
            "schema" : {
              "type" : "file"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "x-handler" : "handlers/workspace/readMetadata.js"
      },
      "put" : {
        "tags" : [ "workspace" ],
        "description" : "write a metadata file at given path. missing parents will be created.",
        "operationId" : "writeMetadata",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "objectPath",
          "in" : "path",
          "description" : "the path (filename without .json) of metadata, without heading /",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "data",
          "in" : "formData",
          "description" : "file contents to write.",
          "required" : true,
          "type" : "file"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK. saved.",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ],
        "x-handler" : "handlers/workspace/writeMetadata.js"
      },
      "delete" : {
        "tags" : [ "workspace" ],
        "description" : "delete metadata of given path",
        "operationId" : "removeMetadata",
        "parameters" : [ {
          "name" : "workspaceId",
          "in" : "path",
          "description" : "webida workspace id (usually same to file system id, wfsId)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "objectPath",
          "in" : "path",
          "description" : "the path (filename without .json) of metadata, without heading /",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "OK. removed",
            "schema" : {
              "$ref" : "#/definitions/RestOK"
            }
          },
          "default" : {
            "description" : "Error",
            "schema" : {
              "$ref" : "#/definitions/RestError"
            }
          }
        },
        "security" : [ {
          "webida-simple-auth" : [ ]
        } ]
      }
    }
  },
  "securityDefinitions" : {
    "webida-simple-auth" : {
      "type" : "apiKey",
      "name" : "Authorization",
      "in" : "header",
      "x-authorize" : "webida-simple-auth.js"
    }
  },
  "definitions" : {
    "RestOK" : {
      "type" : "object",
      "properties" : {
        "message" : {
          "type" : "string"
        }
      }
    },
    "RestError" : {
      "type" : "object",
      "required" : [ "message" ],
      "properties" : {
        "code" : {
          "type" : "string"
        },
        "message" : {
          "type" : "string"
        }
      },
      "description" : "Error object with code and message. code is bound to status code, but not always same to\nstandard HTTP status text. For example, some 409 error may have code \"Invalid Argument\"\ninstead of \"Conflic\". So, Client should read message property to know what happend exactly\nwhen an error is returned from server. And, some 500 errors can have system errno instead\nof useless \"internal\". Like other errors, details are hidden in message.\n"
    },
    "Token" : {
      "type" : "object",
      "required" : [ "expiresAt", "issuedAt", "text", "tokenType" ],
      "properties" : {
        "text" : {
          "type" : "string",
          "description" : "actual token text that should be shipped in header or query"
        },
        "tokenType" : {
          "type" : "string",
          "description" : "MASTER : used to create an access token from clients, without login credential\nACCESS : protects api access. should be unique for each ide session\n\nNote that here\"s no REFRESH token, nor LOGIN token. The login api will create\nunrestricted access token & master token pair. Desktop app has a side-way to\ncreate an unrestricted master token before starting IDE instances.\n",
          "enum" : [ "MASTER", "ACCESS" ]
        },
        "expiresAt" : {
          "type" : "string",
          "format" : "date-time"
        },
        "issuedAt" : {
          "type" : "string",
          "format" : "date-time"
        },
        "sessionId" : {
          "type" : "string",
          "description" : "mandatory for ACCESS token, identifying client instance"
        },
        "workspaceId" : {
          "type" : "string",
          "description" : "If truthy, access rights are restricted to specified workspace only."
        }
      },
      "description" : "a json webtoken and accessible data"
    },
    "Credential" : {
      "type" : "object",
      "required" : [ "loginId", "loginPassword" ],
      "properties" : {
        "loginId" : {
          "type" : "string"
        },
        "loginPassword" : {
          "type" : "string"
        },
        "masterToken" : {
          "type" : "string",
          "description" : "a master token is issued when user wants to access webida api without id/password\nfrom remote or local desktop app. When masterToken is set, client should put some\nbogus id/password, non-empty. (The values can be used to identify client type)\n"
        }
      },
      "description" : "user credential to login. Use https to protect credential."
    },
    "User" : {
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "unique id per user (email is also unique)"
        },
        "email" : {
          "type" : "string"
        },
        "name" : {
          "type" : "string"
        }
      },
      "description" : "Any services/products should define some admin apis to manage users in the system and\nexpose what should be exposed to client app. So, no properties are mandatory.\nCurrently, the properties are defined for compatiblity with legacy clients.\n"
    },
    "Stats" : {
      "type" : "object",
      "required" : [ "birthtime", "mode", "mtime", "nlink", "size", "type" ],
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "All types except 'DUMMY' come from fs.Stats is*** methods results. (e.g. if isFile()\nis true, then type will be 'FILE') If type is not decidable by the methods, default type\nis 'FILE', for everything on the file system is basically a file. 'DUMMY' type means\nthat some object 'does not exist for now'. Client may use 'DUMMY' type to mark something\ndangling, not written or created on real file system yet but visible to user.\n",
          "enum" : [ "FILE", "DIRECTORY", "BLOCK_DEVICE", "CHARACTER_DEVICE", "LINK", "FIFO", "SOCKET", "DUMMY" ]
        },
        "birthtime" : {
          "type" : "string",
          "format" : "date-time"
        },
        "mtime" : {
          "type" : "string",
          "format" : "date-time"
        },
        "mode" : {
          "type" : "string"
        },
        "size" : {
          "type" : "integer"
        },
        "nlink" : {
          "type" : "integer"
        }
      },
      "description" : "simplified/augmented fs.Stats class - see node.js doc for all properties"
    },
    "DirEntry" : {
      "type" : "object",
      "required" : [ "children", "name", "stats" ],
      "properties" : {
        "name" : {
          "type" : "string"
        },
        "stats" : {
          "$ref" : "#/definitions/Stats"
        },
        "children" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/DirEntry"
          }
        }
      },
      "description" : "a directory entry (file or directory) with children that represents a (sub) tree"
    },
    "Match" : {
      "type" : "object",
      "required" : [ "line", "text" ],
      "properties" : {
        "line" : {
          "type" : "integer"
        },
        "text" : {
          "type" : "string"
        }
      },
      "description" : "search result for a file"
    },
    "Workspace" : {
      "type" : "object",
      "required" : [ "createdAt", "description", "excludedPaths", "id", "name", "offlineCachePaths", "workspacePath" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "the id of a workspace. usually same to file system id"
        },
        "name" : {
          "type" : "string",
          "description" : "display text of this workspace for UI"
        },
        "description" : {
          "type" : "string",
          "description" : "human readable description on this workspace"
        },
        "createdAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when this workspace is created (registered from local file system)"
        },
        "accessedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when the last session on this workspace was made. (optional)"
        },
        "workspacePath" : {
          "type" : "string",
          "description" : "absolute path of this workspace in server."
        },
        "excludedPaths" : {
          "type" : "array",
          "description" : "glob patterns (Not regular expression!) or directory paths (Not a file path!) to\nbe excluded for watch service and search & replace operation. If a value has no '*'\nchar, it will be treated as directory path.\n\nLike most of operation parameters, paths (and patterns not prefixed with '*') should\nhave relative, unixified form. If not, server should reject or discard the absolute\n values.\n\nIf a directory is specified to be excluded, watch service may deliver unlinkDir/addDir\nevents of the dir, but should not deliver any events from its sub-dirs and files.\nSearch and replace operation should ignore any files under the directory. If path\ndenotes a file, server may reject or discard the path.\n\nServer should support basic glob pattern,  '**' and '*' in the glob pattern but not !\n'!' prefix is optional. Client should not register any other extended glob features\nthat server does not support.\n",
          "items" : {
            "type" : "string"
          }
        },
        "offlineCachePaths" : {
          "type" : "array",
          "description" : "any paths (including excluded paths) to be cached in remote clients.\n\nBrowser client should respect offline cache paths always. Desktop-app client\nmay not use off-line cache for local (embedded) server but shall use cache for any\nremote servers, even for same host. All caches should be partitioned with workspace\nid, globally unique value through time and space.\n\nClient should pre-fetch the contents of offline cache paths when it start IDE sessions\non a workspace to use for off-line state. When client goes to off-line, after losing\nconnection to server, it can use cached data as reply of some WFS operations and can\nwrite some data to cache to save workspace data & metadata. The changes should be\npersistent on client side safely. C\n\nWhen a client recovers connectivity to server, it should check the stats of files and\ndirs to upload if it has got some changes in offline state. If server has more recents\ncontents, client should drop chagnes and refill the cache with fresher data. Client may\nhave some 'time-tolerance' to accept server's data is fresher than client's, smaller than\nserveral seconds. If server has more recent contents, client should drop the changes and\nrefill the cache with fresher data. If not, client should replay the changes 1 by 1.\n\nSame protocol should be applied when client application starts with some 'unuploaded\nchange' evertime. That means, client should save 'change history' with 'changed data'\ntoo, to process it later, when starting app again in normal condition.\n\nAll Clients should not replay any 'delete' operations while replaying changes on client's\ncache, to protect from more serious problems with skewed timer or unexpected behaviors.\nAnd, of course, client should not rely on cached data while connection state is healthy.\n",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "A workspace in server"
    },
    "RemoteAccess" : {
      "type" : "object",
      "required" : [ "masterToken", "name", "serverUrl", "workspaceId" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "display text of remote workspace. can be different from original name.\n"
        },
        "serverUrl" : {
          "type" : "string",
          "description" : "the url of remote server. Should have no path/query parameters, even \"/\" in path.\n"
        },
        "workspaceId" : {
          "type" : "string",
          "description" : "the id of remote workspace, read from remote server"
        },
        "workspacePath" : {
          "type" : "string",
          "description" : "Full path of remote workspace, read from remote server. this property will be removed\nwhen clients are able to work without \"named root directory\" in workspace fs tree.\n"
        },
        "masterToken" : {
          "type" : "string",
          "description" : "master token to access service, issued from remote server"
        }
      },
      "description" : "Access information of remote workspace in remote server"
    },
    "Session" : {
      "type" : "object",
      "required" : [ "clientAddress", "connectedAt", "disconnectedAt", "id", "name", "state" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "the id of a session. usually same to socket id."
        },
        "name" : {
          "type" : "string",
          "description" : "human readable name, usually derived from workspace name."
        },
        "state" : {
          "type" : "string",
          "description" : "state of this session\n\nNORMAL = connected, normally working\n\nLOSING = disconnected, waiting reconnection. still accessible with api\n\nCLOSING = socket connection will close connection by server (clinet will be notified)\n\nthere\"s no \"CLOSED\" / \"LOST\" state, for server will remove session object in registry\nwhen the server closes connection or stops waiting for reconnection for timeout.\n",
          "enum" : [ "NORMAL", "LOSING", "CLOSING" ]
        },
        "workspaceId" : {
          "type" : "string",
          "description" : "the id of workspace that this sessions is working on. If falsy, then this session is\nnot belonged to any workpsace. Usually, dashboard / monitoring app will create a session\nwithout workspace id.\n"
        },
        "clientAddress" : {
          "type" : "string",
          "description" : "the peer address of session connection. not always"
        },
        "connectedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when socket connection is established"
        },
        "disconnectedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when socket is closed."
        },
        "willCloseAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "when state becomes CLOSING, actual closing time will be updated by server."
        },
        "willLoseAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "when state becomes LOSING, server will not wait for reconnection after this time."
        }
      },
      "description" : "an application session per ide instance. bound to access token"
    },
    "Execution" : {
      "type" : "object",
      "required" : [ "args", "command" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "unique identifier of execution, to demux response stream or cancel request.\nasync exec request should have id, always. For synchronous execution, missing\nid will be generated by server with random string & timestamp.\n"
        },
        "command" : {
          "type" : "string",
          "description" : "command to run. should not contain any arguments, pipes, redirections\n"
        },
        "args" : {
          "type" : "array",
          "description" : "the arguments array",
          "items" : {
            "type" : "string"
          }
        },
        "cwd" : {
          "type" : "string",
          "description" : "Current working directory of spawned process, relative to workspace root. If abscent,\ncwd will be the workspace root directory. Does not accept any evaluatable form like\n$HOME, %USERPROFILE%. As wfs operations, path should be unixified. But, unlikely,\nwhile the wfs operations cut heading \"/\" in path with URI normlization, this operation\ndoes not convert path to relateive and returns error for the argument.\n"
        },
        "input" : {
          "type" : "string",
          "description" : "input string for child process. if falsy, no input will be available to child.\n(interactive execution via websocket is not supported for most of such processes\n requires tty, not standard i/o)\n"
        },
        "timeout" : {
          "type" : "integer",
          "description" : "The value which In \"milliseconds\" the maximum amount of time the child is allowed\nto run. (not idle time of stdout / stderr stream) if undefined, server sets default\ntimeout value 5 min to synchronous execution requests. If request specifies async\nexecution and sets this value to falsy, server should not kill the child process until\n  1) The process exists by self\n  2) cancel operation is invoked by api request\n  3) The workspace executing the process is removed by api request\n  4) Server Stops\nTerminiating any \"too-long-lived\" child process are not graceful, as cancel() is.\n"
        }
      },
      "description" : "execution request, simlilar to node.js spawn(). see node.js documentation for\ndetails of each properties. some properties are not configurable for portability\n   - encoding : fixed to utf-8\n   - shell : fixed to system default. Using shell variables in command may not work.\n   - killSignal : fixed to SIGTERM. If process does not die, server can send SIGKILL or\n                  invoke taskkill to ensure chlid process is killed.\n   - uid & gid : will not be set for security\n   - stdio : all streams are handled by server. no options are avaliable to client.\n   - shell : always false.\n   - detached : always false\n"
    },
    "ExecutionResult" : {
      "type" : "object",
      "required" : [ "exitCode", "stderr", "stdout" ],
      "properties" : {
        "exitCode" : {
          "type" : "integer",
          "description" : "exit code of child process."
        },
        "stdout" : {
          "type" : "string",
          "description" : "standard out of child process."
        },
        "stderr" : {
          "type" : "string",
          "description" : "standard error of child process."
        }
      },
      "description" : "execution response"
    },
    "ChildProcess" : {
      "type" : "object",
      "required" : [ "args", "background", "command", "executionId", "pid", "startedAt" ],
      "properties" : {
        "pid" : {
          "type" : "integer",
          "description" : "child process pid"
        },
        "command" : {
          "type" : "string",
          "description" : "the execution command in Execution request"
        },
        "args" : {
          "type" : "array",
          "description" : "arguments of the command in Execution request",
          "items" : {
            "type" : "string"
          }
        },
        "executionId" : {
          "type" : "string",
          "description" : "execution id from Execution request"
        },
        "startedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "the time when this process is spawned"
        },
        "background" : {
          "type" : "array",
          "description" : "true when this process is spawned by asynchronous exec request or some other ways to\nspawn processes in server. fasle when this process is spawened with plain, synchronous\nexecution request.\n",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "a process in execution"
    }
  },
  "parameters" : {
    "wfsId" : {
      "name" : "wfsId",
      "in" : "path",
      "description" : "webida file system id (same to workspace id) to access.",
      "required" : true,
      "type" : "string"
    },
    "wfsPath" : {
      "name" : "wfsPath",
      "in" : "path",
      "description" : "webida file system path to access. without heading /. should be placed at the end of path arguments\n",
      "required" : true,
      "type" : "string",
      "pattern" : ".*"
    },
    "srcPath" : {
      "name" : "srcPath",
      "in" : "query",
      "description" : "source data path of some operations, with have heading /",
      "required" : true,
      "type" : "string"
    },
    "wfsPathList" : {
      "name" : "wfsPathList",
      "in" : "query",
      "description" : "array of wfsPath, with heading /  (collection format may be changed by implementation)",
      "required" : true,
      "type" : "array",
      "items" : {
        "type" : "string"
      },
      "collectionFormat" : "multi"
    },
    "ensureParents" : {
      "name" : "ensureParents",
      "in" : "query",
      "description" : "A flag to create all parent directories to create file or dir, like mkdir -p. This parameter\ndoes not create entire path, but creates to 'parent directory' of the path.\n",
      "required" : false,
      "type" : "boolean",
      "default" : false
    },
    "noOverwrite" : {
      "name" : "noOverwrite",
      "in" : "query",
      "description" : "does not overwrites any existing file while copying or moving",
      "required" : false,
      "type" : "boolean",
      "default" : false
    },
    "pattern" : {
      "name" : "pattern",
      "in" : "query",
      "description" : "regex pattern to match in search or replace.\nIn replace operation, pattern should be same to the parttern in search operation\n",
      "required" : true,
      "type" : "string"
    },
    "ignoreCase" : {
      "name" : "ignoreCase",
      "in" : "query",
      "description" : "regex matching option to ignore case.\nIn replace operation, this option should be same to one used in search operation\n",
      "required" : false,
      "type" : "boolean",
      "default" : false
    },
    "workspaceId" : {
      "name" : "workspaceId",
      "in" : "path",
      "description" : "webida workspace id (usually same to file system id, wfsId)",
      "required" : true,
      "type" : "string"
    },
    "objectPath" : {
      "name" : "objectPath",
      "in" : "path",
      "description" : "the path (filename without .json) of metadata, without heading /",
      "required" : true,
      "type" : "string"
    },
    "sessionId" : {
      "name" : "sessionId",
      "in" : "path",
      "description" : "webida session id (usually different from socket id from sock.io)",
      "required" : true,
      "type" : "string"
    }
  }
}